Проект для обределения цвета и формата кубика всего лишь по его фотографии(вид сверху)
Предпологается что проект может использоваться в промышленных целях, а именно сортировки
Ведь с помощью этого проекта можно проводить сортировку всего лишь с помощью камеры
В моем случае проект представлен в виде приложения, пользователь которого может сам вставить фотографию
в репозитории указан файл с кодом, файл requirements.txt, файл main.exe, который открывает программу без запуска кода а как отдельное приложение, а также три фотографии - 'img_2.png', 'img_3.png', 'img_4.png' для которых осущствленны базовые настройки и на примере которых можно увидеть какие трудности существуют и какие минусы сущесмтвуют у метода определения формата по фотграфии
всего в проекте  около 550 строк 8 классов и 6 библиотек
В проекте используются библиотеки - numpy, PIL, sys, pyqt, maptolib, а также open-cv(cv2) из которой я взял математическую функцию которая помогает опредилить окружности и линии по фотографии
Для определения формата я решил что необходимо определить рамки фигуры, а также количество выпуклых "пупырышек" - на картинке это кружочки, через координаты найденых  фигур можно найти цвет
для опредделения прямых и кружочков на фотографии я использовал метод преобразования Хафа который существует в библиотекке open-cv в кратце суть преобразованияя 
для прямых - выражение уравнения прямых через углы в жекартовых координатах тогда графики этих функций для несольких точек лежащих на одной точке которая будет задавать еще одну прямую и тогда на пространстве хафа - картинке будет несколько спектров и несколько ярких точек - которые задают прямые - подробнее можно узнать на сайте https://polarnick.com/blogs/239/2021/school239_11_2021_2022/2021/11/02/lesson8-hough-transform.html 
для окружностей - также существует уравнение через углы и декартовы координаты радиуса и центра окружности - подробнее https://docs.opencv.org/3.4/d4/d70/tutorial_hough_circle.html
первый класс - line_finder  имеет несколько методов
первый graing - задает черно-белую маску картинки, второй finding - находит прямый алгоритмом Хафа третий рисует по полученным координатам линии на картинке - lining, четвертый отправляет результат а точнее данные найденных прямых для - отсортировки ненужных найденных прямых и возвращения отрезков ведь алгоритм находит полноценные прямые а нужно получить рамку или отношение сторон
 пятый -  вызывает фотографию формата maptolib с найденными прямыми, не вызывается в программе ведь для всех ситуаций прямых одни и те же параметры алгоритма Хафа в отличие от нахождения кружков но с помощью него можно проверить из-за чего могут возникать ошибки а также понять какие лишние прямые алгоритм находит на картинке - пример найденных прямых ![image](https://github.com/user-attachments/assets/4b7c744f-41c5-43ec-8c22-b53e2dde9cf0)
второй класс - circle_finder
первые два метода похожи на первые два метода для класса прямых, но метод нахождения прямых отличается за счет того что что для разных картинок необходимы разные параметры в нашем случае это img - картинка, задается пользователем, method - существует единственный, dp -коэфициент показывающий какое сжатие или растяжение необходимо для картинки, min_dist - минимальное расстояние между кружочками, param1 - больший аккумулятор сколпения точек на пространстве Хафа, param2 - меньший(более узкий) аккумулятор скопления точек на пространстве Хафа, minRadius - минимальный радиус кружка, maxRaduis - максимальный радиус кружка
базовые параметры - [1,1,75,40,0,0] или [1,5,75,40,0,0]
следующий метод - non-maximum_suoression - метод который сортирует круги по списку  координат через исключение лишних кружков найденных в одной точке(в билжайших) следующие методы подобные методам прямой функции отрисовывают кружки на картинке отправляют список координат а также в отличии от прямой метод открытия картинки вызывается, скриншот подобный прямым будет приложен далее
класс blocks вызывает два предыдущих с целью получения координат кружков и прямых а также сортирует прямые - сначала исчет прямые которые являются параллельными или приблизительно паралелльными и откладывает их в несколько списков в каждом из которых - горизонтальные и вертикальные прямые (или взаимоперпендикулярные) затем в списках сортирует паралелльные прямые так чтобы остались только две в каждом из них затем находит их координаты и отезки создающиеся их пересечениями, а также находит отношения и через количество кружков(даже если не все были найдены на картинке) находит формат блока лего
класс median_color - вычесляет средний цвет картинки
класс PhotoViewer создает само приложение начальный интерфейс которого выглядит так ![image](https://github.com/user-attachments/assets/4ff6319f-f90d-445c-8a9b-077cc0982db9)
где нам предлагается пять кнопок
about program - открывает окно с минимальной информацией о проекте весь текст задан в классе InfoWindow и выглядит так ![image](https://github.com/user-attachments/assets/270a04d5-77be-44b7-ab61-2e26c42ba601)
кнопка settings отправляет нас в настройки где мы можем устанавливать параметры для своей картинки для нахождения кружков на ней - описан в классе  SettingsDialog и отправляет данные в список List_With который испольщуется в классе  parameters для обработки, при указании неправильныз некоректных параметров они сохранятся до следующего изменения , программа может перестать работать если при открытии файла будут использованы некоректные данные, начальные параметры уже заданы но не отображаются в последующих выводах![image](https://github.com/user-attachments/assets/3791dbb4-c5af-4514-bf3f-0b31518b7692)
при правильном вводе откроется сообщение ![image](https://github.com/user-attachments/assets/8975e6f7-5e2a-4859-8404-ba678122202e)
при непраильном также откроется соответствующее сообщение![image](https://github.com/user-attachments/assets/7c03416d-10f5-46b8-b840-98ce1226b629)
кнопка check your correction открывает нам фотографию которую мы выберем с соответствующими отмеченными кружками на ней, если незначительное количество не было найдено или были найдены все то все работает корректно и можно работать с фотографиями такого же формата с указанными данными, ![image](https://github.com/user-attachments/assets/c80ec685-dd66-4446-a4c0-d2cbfe368eff)
![image](https://github.com/user-attachments/assets/ae202a09-b9da-490e-a417-bf55f9fe703d)
кнопка open photo предложит вам выбрать фотографию которая будет отобрадатся в самом вверху также у вас все еще будет доступ к остальным пяти а снизу будет несколько строк содержащие такуюу информация как название открытого файла, дату и время, формат кубика, медианный цвет картинки и цвет блока в формате трех чисел RGB ,а также введенные параметры(если такие существуют) ![image](https://github.com/user-attachments/assets/25798370-058d-4a2a-b0df-b3229ba3bafb)
функция кнопки check your data_base описывается в классе DBSample, а также методах openCSV, data_base, updating_table, а именно она создает базу данных в который вписывает номерной порядок каждой попытки открыть файл, а также название открытого файла, дату и время, формат кубика, медианный цвет картинки и цвет блока в формате трех чисел RGB ,а также введенные параметры(если такие существуют), база данных обновляется с каждой новой открытой картинкой, а также ее можно открыть как таблицу с данными(рисунок можно было записать либо как название файла либо как строку формата BLOB а точнее двоичный код, который занимал бы очень много памяти и который не принесет нужного результата) ![image](https://github.com/user-attachments/assets/5aa24f0b-f6c2-4498-a2b3-e7cfcd404825)
также во множестве классов и функций учитывается возможность невверного введения данных пользователем о чем он получит сообщнеие
несомненно программе не всегда удается четко получить данные из-за неиделаьности фотографии или самого метода, что либо устраняется математическими функциями которые я описывал, либо при получении множества разных кадров примерно одного ракурса и усреднения полученных данных, но в полученные мною результаты показали двольно неплохую точность
В будующем я планирую улучшить проект, а именно улучшить точность сортировки и нахождения, а также сделать определение формата по полноценному трех-мерному(когда видно несколько граней параллелепипеда) изображению и добавление не только прямоугольных деталей
